package utopia.vault.coder.model.data

import utopia.flow.datastructure.immutable.{ModelDeclaration, ModelValidationFailedException}
import utopia.flow.datastructure.template
import utopia.flow.generic.{FromModelFactory, StringType}
import utopia.flow.generic.ValueUnwraps._
import utopia.flow.parse.Regex
import utopia.flow.util.CollectionExtensions._
import utopia.flow.util.StringExtensions._
import utopia.vault.coder.model.data.CustomPropertyType.{pluralRegex, singularRegex, valueRegex}
import utopia.vault.coder.model.enumeration.NamingConvention.CamelCase
import utopia.vault.coder.model.enumeration.ConcretePropertyType
import utopia.vault.coder.model.scala.code.CodePiece
import utopia.vault.coder.model.scala.datatype.{Reference, ScalaType}

import scala.util.{Failure, Success}

object CustomPropertyType extends FromModelFactory[CustomPropertyType]
{
	// ATTRIUTES    ---------------------------
	
	private val parameterIndicatorRegex = Regex.escape('$')
	/**
	  * Regular expression used for finding value (parameter) references within user-defined code pieces
	  */
	private val valueRegex = parameterIndicatorRegex + "v"
	private val singularRegex = parameterIndicatorRegex + "s"
	private val pluralRegex = parameterIndicatorRegex + "p"
	
	private lazy val schema = ModelDeclaration("type" -> StringType, "sql" -> StringType)
	
	
	// IMPLEMENTED  -------------------------
	
	override def apply(model: template.Model[template.Property]) =
		schema.validate(model).toTry.flatMap { model =>
			// from_value, from_values and to_value must all exist and contain the appropriate parameter placeholder
			Vector("from_value", "to_value", "option_from_value")
				.findMap { propName =>
					model(propName).string match {
						case Some(code) =>
							if (valueRegex.existsIn(code))
								None
							else
								Some(s"$propName doesn't contain the appropriate value reference ('$valueRegex')")
						case None => Some(s"$propName is missing")
					}
				} match
			{
				case Some(failureMessage) => Failure(new ModelValidationFailedException(failureMessage))
				case None =>
					val default: CodePiece = model("default")
					Success(apply(ScalaType(model("type")), model("sql"), model("from_value"),
						model("option_from_value"), model("to_value"), model("option_to_value"), default,
						model("sql_default"), model("prop_name", "property_name", "default_prop_name", "default_name"),
						model("col_suffix", "column_suffix", "suffix"), model("description", "doc", "desc"),
						model("index", "is_index", "default_index", "default_indexing")))
			}
		}
	
	
	// NESTED   --------------------------
	
	
}

/**
  * Represents a user-created property type
  * @author Mikko Hilpinen
  * @since 17.7.2022, v1.15.1
  * @param dataType The wrapped scala data type
  * @param sql Sql representation of this property type (without default or "NOT NULL" -segments)
  * @param fromValue Code that takes a Value (represented by $v) and returns an instance of this type
  * @param optionFromValue Code that takes a Value ($v) and returns an option containing an instance of this type
  * @param toValue Code that takes an instance of this type (represented by $v) and returns a Value
  * @param optionToValue Code that takes an option (with this instance) ($v) and returns a Value
  *                      (default = empty = autogenerate)
  * @param defaultValue The default value for this data type within scala code (default = empty = no default value)
  * @param sqlDefault The default value for this data type within sql
  *                   (default = empty = no default value or default value from base default)
  * @param defaultPropName The default property name generated by this data type (default = None = same as data type name)
  * @param colNameSuffix A suffix added to generated column names when this data type is used, not including the
  *                      separator (e.g. '_') (default = empty = no suffix)
  * @param autoDescription Automated documentation written for properties of this type by default.
  *                        Each occurrence of $s is replaced with a singular class name and each occurrence of $p is
  *                        replaced with a plural class name.
  * @param indexByDefault Whether this type creates an SQL index by default (default = false)
  */
case class CustomPropertyType(dataType: ScalaType, sql: String, fromValue: CodePiece, optionFromValue: CodePiece,
                              toValue: CodePiece, optionToValue: CodePiece = CodePiece.empty,
                              defaultValue: CodePiece = CodePiece.empty,
                              private val sqlDefault: String = "", defaultPropName: Option[Name] = None,
                              colNameSuffix: String = "", autoDescription: String = "",
                              indexByDefault: Boolean = false)
	extends ConcretePropertyType
{
	// IMPLEMENTED  ----------------------------
	
	override def toScala = dataType
	
	override def toBaseSql = sql
	
	override def baseSqlDefault = sqlDefault.notEmpty.getOrElse { defaultValue.toSql.getOrElse("") }
	
	override def defaultPropertyName =
		defaultPropName.getOrElse { Name.interpret(dataType.toString, CamelCase.capitalized) }
	
	override def columnNameSuffix = colNameSuffix.notEmpty
	
	override def createsIndexByDefault = indexByDefault
	
	override def fromValueCode(valueCode: String) = finalizeCode(fromValue, valueCode)
	override def toValueCode(instanceCode: String) = finalizeCode(toValue, instanceCode)
	override def optionFromValueCode(valueCode: String) = finalizeCode(optionFromValue, valueCode)
	override def optionToValueCode(optionCode: String) = optionToValue.notEmpty match {
		// Case: Using a user-defined conversion
		case Some(toValue) => finalizeCode(toValue, optionCode)
		// Case: No user-defined conversion available
		case None =>
			toValueCode("v")
				.mapText { toValue => s"$optionCode.map { v => $toValue }.getOrElse(Value.empty)" }
				.referringTo(Reference.value)
	}
	
	override def writeDefaultDescription(className: Name, propName: Name) =
		autoDescription
			.replaceAll(singularRegex, className.toText.singular)
			.replaceAll(pluralRegex, className.pluralText)
	
	
	// OTHER    ----------------------------
	
	private def finalizeCode(userCode: CodePiece, parameterCode: String) =
		userCode.mapText { _.replaceAll(valueRegex, parameterCode) }
}
