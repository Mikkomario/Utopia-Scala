package utopia.vault.coder.model.datatype

import utopia.flow.datastructure.immutable.{ModelDeclaration, ModelValidationFailedException}
import utopia.flow.datastructure.template
import utopia.flow.generic.ValueUnwraps._
import utopia.flow.generic.{FromModelFactory, StringType}
import utopia.flow.parse.Regex
import utopia.flow.util.CollectionExtensions._
import utopia.flow.util.StringExtensions._
import utopia.vault.coder.model.data.Name
import utopia.vault.coder.model.datatype.CustomPropertyType.{pluralRegex, singularRegex, valueRegex}
import utopia.vault.coder.model.enumeration.NamingConvention.CamelCase
import utopia.vault.coder.model.scala.code.CodePiece
import utopia.vault.coder.model.scala.datatype.{Reference, ScalaType}

import scala.util.{Failure, Success}

object CustomPropertyType extends FromModelFactory[CustomPropertyType]
{
	// ATTRIUTES    ---------------------------
	
	private val parameterIndicatorRegex = Regex.escape('$')
	/**
	  * Regular expression used for finding value (parameter) references within user-defined code pieces
	  */
	private val valueRegex = parameterIndicatorRegex + "v"
	private val singularRegex = parameterIndicatorRegex + "s"
	private val pluralRegex = parameterIndicatorRegex + "p"
	
	private lazy val schema = ModelDeclaration("type" -> StringType, "sql" -> StringType)
	
	
	// IMPLEMENTED  -------------------------
	
	override def apply(model: template.Model[template.Property]) =
		schema.validate(model).toTry.flatMap { model =>
			// from_value, from_values and to_value must all exist and contain the appropriate parameter placeholder
			Vector("from_value", "to_value", "option_from_value")
				.findMap { propName =>
					model(propName).string match {
						case Some(code) =>
							if (valueRegex.existsIn(code))
								None
							else
								Some(s"$propName doesn't contain the appropriate value reference ('$valueRegex')")
						case None => Some(s"$propName is missing")
					}
				} match
			{
				case Some(failureMessage) => Failure(new ModelValidationFailedException(failureMessage))
				case None =>
					val default: CodePiece = model("default")
					val sqlDefault = model("sql_default").stringOr { default.toSql.getOrElse("") }
					val sqlType = SqlPropertyType(model("sql"), sqlDefault,
						model("col_suffix", "column_suffix", "suffix"),
						indexByDefault = model("index", "is_index", "default_index", "default_indexing"))
					Success(apply(ScalaType(model("type")), sqlType, model("from_value"),
						model("option_from_value"), model("to_value"), model("option_to_value"), default,
						model("prop_name", "property_name", "default_prop_name", "default_name"),
						model("description", "doc", "desc"),
						model("from_value_can_fail", "yields_try", "try")))
			}
		}
	
	
	// NESTED   --------------------------
	
	
}

/**
  * Represents a user-created property type
  * @author Mikko Hilpinen
  * @since 17.7.2022, v1.15.1
  * @param scalaType The wrapped scala data type
  * @param sqlType Sql representation of this property type
  * @param fromValue Code that takes a Value (represented by $v) and returns an instance of this type
  * @param optionFromValue Code that takes a Value ($v) and returns an option containing an instance of this type
  * @param toValue Code that takes an instance of this type (represented by $v) and returns a Value
  * @param optionToValue Code that takes an option (with this instance) ($v) and returns a Value
  *                      (default = empty = autogenerate)
  * @param emptyValue An "empty" value applicable to this type. Empty if there is no applicable value (default).
  * @param nonEmptyDefaultValue The default value for this data type within scala code, but only if different from
  *                             emptyValue (default = empty = no default value)
  * @param defaultPropName The default property name generated by this data type (default = None = same as data type name)
  * @param autoDescription Automated documentation written for properties of this type by default.
  *                        Each occurrence of $s is replaced with a singular class name and each occurrence of $p is
  *                        replaced with a plural class name.
  * @param yieldsTryFromValue Whether fromValue code yields a Try instead of an instance of this type (default = false)
  */
case class CustomPropertyType(scalaType: ScalaType, sqlType: SqlPropertyType, fromValue: CodePiece, optionFromValue: CodePiece,
                              toValue: CodePiece, optionToValue: CodePiece = CodePiece.empty,
                              emptyValue: CodePiece = CodePiece.empty,
                              nonEmptyDefaultValue: CodePiece = CodePiece.empty,
                              defaultPropName: Option[Name] = None, autoDescription: String = "",
                              yieldsTryFromValue: Boolean = false)
	extends ConcretePropertyType
{
	// IMPLEMENTED  ----------------------------
	
	override def defaultPropertyName =
		defaultPropName.getOrElse { Name.interpret(scalaType.toString, CamelCase.capitalized) }
	
	// TODO: Add support for multi-column data-types
	override def fromValueCode(valueCode: String, multipleValues: Boolean) = finalizeCode(fromValue, valueCode)
	override def toValueCode(instanceCode: String) = finalizeCode(toValue, instanceCode)
	override def optionFromValueCode(valueCode: String) = finalizeCode(optionFromValue, valueCode)
	override def optionToValueCode(optionCode: String) = optionToValue.notEmpty match {
		// Case: Using a user-defined conversion
		case Some(toValue) => finalizeCode(toValue, optionCode)
		// Case: No user-defined conversion available
		case None =>
			toValueCode("v")
				.mapText { toValue => s"$optionCode.map { v => $toValue }.getOrElse(Value.empty)" }
				.referringTo(Reference.value)
	}
	
	override def writeDefaultDescription(className: Name, propName: Name) =
		autoDescription
			.replaceAll(singularRegex, className.toText.singular)
			.replaceAll(pluralRegex, className.pluralText)
	
	
	// OTHER    ----------------------------
	
	private def finalizeCode(userCode: CodePiece, parameterCode: String) =
		userCode.mapText { _.replaceAll(valueRegex, parameterCode) }
}
