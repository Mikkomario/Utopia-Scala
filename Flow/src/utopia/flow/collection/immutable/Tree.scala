package utopia.flow.collection.immutable

import utopia.flow.operator.EqualsFunction

object Tree
{
	/**
	  * Creates a new tree that consists of a single linear branch that doesn't divide at any point
	  * @param b Items to place on this branch, from the root to the leaf
	  * @param navEquals An implicit equals function to use when comparing navigational elements in this tree.
	  *                  Default is ==
	  * @tparam A Type of nav elements used by this tree
	  * @throws NoSuchElementException If the specified branch is empty
	  * @return A new tree
	  */
	@throws[NoSuchElementException]("If the specified branch is empty")
	def branch[A](b: Seq[A])(implicit navEquals: EqualsFunction[A] = EqualsFunction.default): Tree[A] = {
		val tail = b.tail
		if (tail.isEmpty)
			apply(b.head)
		else
			apply(b.head, Vector(branch(b.tail)))
	}
	
	
	/**
	  * Creates a new tree with a recursive function.
	  * The whole tree structure is initialized at once. For lazily initialized structures,
	  * see [[utopia.flow.collection.immutable.caching.LazyTree]]
	  * @param root The root node nav-element
	  * @param goDeeper A function that accepts a nav-element and returns the nav-elements of the nodes directly
	  *                 below.
	  *
	  *                 This function must return empty vectors at some point, otherwise an infinite recursive
	  *                 loop will ensue.
	  * @tparam A Type of nav-elements used by this tree structure
	  * @return A tree generated by the specified function
	  */
	def iterate[A](root: A)(goDeeper: A => Vector[A]): Tree[A] =
		apply(root, goDeeper(root).map { nav => iterate(nav)(goDeeper) })
}

/**
  * This TreeNode implementation is immutable and safe to reference from multiple places
  * @author Mikko Hilpinen
  * @since 4.11.2016
  */
case class Tree[A](override val nav: A, override val children: Vector[Tree[A]] = Vector())
                  (implicit override val navEquals: EqualsFunction[A] = EqualsFunction.default)
	extends TreeLike[A, Tree[A]]
{
	// IMPLEMENTED    ---------------
	
	override def repr = this
	
	override protected def createCopy(content: A, children: Seq[Tree[A]]) = Tree(content, children.toVector)
	
	override protected def newNode(content: A) = Tree(content)
	
	
	// OTHER METHODS    -------------
	
	/**
	  * Maps the content of all nodes in this tree
	  * @param f A mapping function
	  * @tparam B Target content type
	  * @return A mapped version of this tree
	  */
	def map[B](f: A => B)(implicit equals: EqualsFunction[B]): Tree[B] =
		Tree(f(nav), children.map { _.map(f) })(equals)
	
	/**
	  * Maps the content of all nodes in this tree. May map to None where the node is removed.
	  * @param f A mapping function
	  * @tparam B Target content type
	  * @return A mapped version of this tree. None if the content of this node mapped to None.
	  */
	def flatMap[B](f: A => Option[B])(implicit equals: EqualsFunction[B]): Option[Tree[B]] =
		f(nav).map { c => Tree(c, children.flatMap { _.flatMap(f) })(equals) }
}
