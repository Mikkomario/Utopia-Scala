package utopia.genesis.handling.event.mouse

import utopia.flow.async.context.ActionQueue
import utopia.flow.async.process.Breakable
import utopia.flow.collection.immutable.Pair
import utopia.flow.view.immutable.caching.Lazy
import utopia.flow.view.immutable.eventful.AlwaysTrue
import utopia.flow.view.mutable.eventful.Flag
import utopia.flow.view.template.eventful.{Changing, FlagLike}
import utopia.genesis.handling.action.{Actor, ActorHandler}
import utopia.genesis.handling.template.Handlers
import utopia.paradigm.shape.shape2d.vector.Vector2D
import utopia.paradigm.shape.shape2d.vector.point.{Point, RelativePoint}

import java.awt.event.{MouseEvent, MouseListener, MouseWheelListener}
import java.awt.{Component, MouseInfo}
import scala.concurrent.duration.FiniteDuration
import scala.concurrent.{ExecutionContext, Future}
import scala.ref.WeakReference
import scala.util.Try

object MouseEventGenerator
{
    /**
      * Creates a new mouse event generator and attaches it to an ActorHandler
      * @param handler The ActorHandler that will deliver action events to this generator
      * @param component The component on which mouse button and wheel events are received
      * @param activeCondition Condition on which mouse-listening is performed (default = always listen)
      * @param exc Implicit execution context (used for delivering mouse events)
      * @return A new mouse event generator, already attached to the specified ActorHandler
      */
    def apply(handler: ActorHandler, component: Component, activeCondition: Changing[Boolean] = AlwaysTrue)
             (implicit exc: ExecutionContext) =
    {
        val generator = new MouseEventGenerator(component, activeCondition)
        handler += generator
        generator
    }
}

/**
 * This class listens to mouse status inside a component and generates mouse events.
  * This class implements the Actor trait so in order to work, it should be added to a working
 * ActorHandler.
 * @author Mikko Hilpinen
 * @since 22.1.2017
 */
class MouseEventGenerator(c: Component, activeCondition: Changing[Boolean] = AlwaysTrue)
                         (implicit exc: ExecutionContext)
    extends Actor with Breakable
{
    // ATTRIBUTES    -----------------
    
    // Set once this generator should stop generating events
    private val stopFlag = Flag()
    override val handleCondition: FlagLike = !stopFlag && activeCondition
    
    // Generated events are fired one at a time using an event queue
    private val eventQueue = new ActionQueue()
    
    private val componentPointer = WeakReference(c)
    
    private val lazyMoveHandler = Lazy { MouseMoveHandler.empty }
    private val lazyButtonHandler = Lazy {
        component.foreach { _.addMouseListener(MouseButtonEventReceiver) }
        MouseButtonStateHandler.empty
    }
    private val lazyWheelHandler = Lazy {
        component.foreach { _.addMouseWheelListener(MouseWheelEventReceiver) }
        MouseWheelHandler.empty
    }
    /**
      * Handlers that receive the events generated by this generator
      */
    lazy val handlers = Handlers(moveHandler, buttonHandler, wheelHandler)
    
    // Adjustment vector added to generated mouse positions
    // For windows, the window insets must be accounted for
    private lazy val positionAdjustment = component match {
        case Some(c) =>
            c match {
                case window: java.awt.Window =>
                    val insets = window.getInsets
                    Vector2D(-insets.left, -insets.top)
                case _ => Vector2D.zero
            }
        case None => Vector2D.zero
    }
    
    private var position = RelativePoint.origin
    private var buttonStates = MouseButtonStates.default
    
    
    // INITIAL CODE ------------------
    
    activeCondition.onceFixedAt(false) { stop() }
    
    
    // COMPUTED ----------------------
    
    /**
      * @return A flag that contains true once this generator has been stopped
      */
    def stoppedFlag = stopFlag.view
    /**
      * @return True if this generator has been stopped
      */
    def hasStopped = stopFlag.value
    /**
      * @return True if this generator has not been stopped (i.e. is or will be still generating events)
      */
    def hasNotStopped = !hasStopped
    
    /**
      * @return A handler that distributes generated mouse move events
      */
    def moveHandler = lazyMoveHandler.value
    /**
      * @return A handler that distributes generated mouse button state events
      */
    def buttonHandler = lazyButtonHandler.value
    /**
      * @return A handler that distributes generated mouse wheel events
      */
    def wheelHandler = lazyWheelHandler.value
    
    private def component = componentPointer.get
    
    
    // IMPLEMENTED    ------------------
    
    override def stop(): Future[Any] = {
        component.foreach { c =>
            c.removeMouseListener(MouseButtonEventReceiver)
            c.removeMouseWheelListener(MouseWheelEventReceiver)
            componentPointer.clear()
        }
        lazyMoveHandler.current.foreach { _.clear() }
        lazyButtonHandler.current.foreach { _.clear() }
        lazyWheelHandler.current.foreach { _.clear() }
        stopFlag.set()
        Future.successful(())
    }
    
    override def act(duration: FiniteDuration) = {
        component.foreach { c =>
            // Checks for mouse movement
            // Sometimes mouse position can't be calculated, in which case assumes mouse to remain static
            Try { Option(MouseInfo.getPointerInfo) }.toOption.flatten.foreach { pointerInfo =>
                val absoluteMousePosition = Point of pointerInfo.getLocation
                val newPosition = RelativePoint
                    .relativeByAbsolute(absoluteMousePosition) { pointInPanel(_, c) + positionAdjustment }
                
                // Case: Mouse position changed
                if (newPosition.absolute != position.absolute) {
                    // Updates the local variables
                    val previousMousePosition = position
                    position = newPosition
                    
                    // Informs the handler only if one has been generated
                    lazyMoveHandler.current.foreach { handler =>
                        val event = MouseMoveEvent(Pair(previousMousePosition, position), duration, buttonStates)
                        eventQueue.push { handler.onMouseMove(event) }
                    }
                }
            }
        }
    }
    
    
    // OTHER METHODS    --------------
    
    /**
      * Simulates the release of all currently held-down mouse buttons
      */
    def releaseAllKeys() = {
        // Updates local button status
        if (buttonStates.areSomePressed) {
            val oldButtonStates = buttonStates
            buttonStates = MouseButtonStates.default
    
            // Informs attached listeners for each released key
            if (handleCondition.value)
                lazyButtonHandler.current.foreach { handler =>
                    oldButtonStates.buttonsPressed.foreach { releasedButton =>
                        val event = MouseButtonStateEvent(releasedButton, position, buttonStates, None,
                            pressed = false)
                        eventQueue.push { handler.onMouseButtonStateEvent(event) }
                    }
                }
        }
    }
    
    @scala.annotation.tailrec
    private def pointInPanel(point: Point, panel: Component): Point = {
        val relativePoint = point - (Point of panel.getLocation)
        panel match {
            case _: java.awt.Window => relativePoint
            case _ =>
                val parent = panel.getParent
                if (parent == null) relativePoint else pointInPanel(relativePoint, parent)
        }
    }
    
    
    // NESTED CLASSES    ------------
    
    private object MouseButtonEventReceiver extends MouseListener
    {
        // IMPLEMENTED  -------------
        
        override def mousePressed(e: MouseEvent) = distributeEvent(e, pressed = true)
        override def mouseReleased(e: MouseEvent) = distributeEvent(e, pressed = false)
        
        override def mouseClicked(e: MouseEvent) = ()
        override def mouseEntered(e: MouseEvent) = ()
        override def mouseExited(e: MouseEvent) = ()
        
        
        // OTHER    ---------------
        
        private def distributeEvent(event: MouseEvent, pressed: Boolean) = {
            val button = MouseButton(event.getButton)
            buttonStates = buttonStates.withButtonState(button, pressed)
            if (handleCondition.value)
                lazyButtonHandler.current.foreach { handler =>
                    val newEvent = MouseButtonStateEvent(button, position, buttonStates, None, pressed = pressed)
                    // Distributes the event asynchronously
                    eventQueue.push { handler.onMouseButtonStateEvent(newEvent) }
                }
        }
    }
    
    private object MouseWheelEventReceiver extends MouseWheelListener
    {
        override def mouseWheelMoved(e: java.awt.event.MouseWheelEvent) = {
            if (handleCondition.value)
                lazyWheelHandler.current.foreach { handler =>
                    val event = MouseWheelEvent(e.getWheelRotation, position, buttonStates)
                    // Distributes the event asynchronously
                    eventQueue.push { handler.onMouseWheelRotated(event) }
                }
            }
    }
}